<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="prev" title="plum" href="modules.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>plum module - Plum 1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">Plum 1.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  
  <span class="sidebar-brand-text">Plum 1.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="modules.html">plum</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">plum module</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="module-plum">
<span id="plum-module"></span><h1>plum module<a class="headerlink" href="#module-plum" title="Permalink to this heading">#</a></h1>
<p>A sage module for analyzing manifolds plumbed along 2-spheres.</p>
<p>This module enables the user to enter a plumbing diagram and return basic
information about the corresponding 3- and 4-dimensional manifolds,
for example the intersection form, homology, etc.</p>
<p>For negative definite plumbing trees equipped with a spin^c structure, the
program can also compute the weighted graded root <span id="id1">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span>,
<span class="math notranslate nohighlight">\(\widehat{Z}\)</span> invariant <span id="id2">[<a class="reference internal" href="#id13" title="Sergei Gukov, Du Pei, Pavel Putrov, and Cumrun Vafa. BPS spectra and 3-manifold invariants. J. Knot Theory Ramifications, 29(2):2040003, 85, 2020. doi:10.1142/S0218216520400039.">GPPV20</a>]</span>, and the
<span class="math notranslate nohighlight">\(\widehat{\widehat{Z}}\)</span> invariant <span id="id3">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span>.</p>
<div class="docutils container" id="id4">
<div class="citation" id="id28" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>AJK21<span class="fn-bracket">]</span></span>
<p>Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. <em>arXiv preprint arXiv:2109.14139</em>, 2021.</p>
</div>
<div class="citation" id="id17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>BMM20<span class="fn-bracket">]</span></span>
<p>Kathrin Bringmann, Karl Mahlburg, and Antun Milas. Quantum modular forms and plumbing graphs of 3-manifolds. <em>J. Combin. Theory Ser. A</em>, 170:105145, 32, 2020. <a class="reference external" href="https://doi.org/10.1016/j.jcta.2019.105145">doi:10.1016/j.jcta.2019.105145</a>.</p>
</div>
<div class="citation" id="id16" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>CCF+19<span class="fn-bracket">]</span></span>
<p>Miranda C.N. Cheng, Sungbong Chun, Francesca Ferrari, Sergei Gukov, and Sarah M. Harrison. 3d modularity. <em>J. High Energy Phys.</em>, pages 010, 93, 2019. <a class="reference external" href="https://doi.org/10.1007/jhep10(2019)010">doi:10.1007/jhep10(2019)010</a>.</p>
</div>
<div class="citation" id="id26" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>DM19<span class="fn-bracket">]</span></span>
<p>Irving Dai and Ciprian Manolescu. Involutive Heegaard Floer homology and plumbed three-manifolds. <em>J. Inst. Math. Jussieu</em>, 18(6):1115–1155, 2019. <a class="reference external" href="https://doi.org/10.1017/s1474748017000329">doi:10.1017/s1474748017000329</a>.</p>
</div>
<div class="citation" id="id5" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Don83<span class="fn-bracket">]</span></span>
<p>S. K. Donaldson. An application of gauge theory to four-dimensional topology. <em>J. Differential Geom.</em>, 18(2):279–315, 1983.</p>
</div>
<div class="citation" id="id8" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Flo88<span class="fn-bracket">]</span></span>
<p>Andreas Floer. An instanton-invariant for 3-manifolds. <em>Comm. Math. Phys.</em>, 118(2):215–240, 1988.</p>
</div>
<div class="citation" id="id20" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GS99<span class="fn-bracket">]</span></span>
<p>Robert E. Gompf and András I. Stipsicz. <em>4-manifolds and Kirby calculus</em>. Volume 20 of Graduate Studies in Mathematics. American Mathematical Society, Providence, RI, 1999. ISBN 0-8218-0994-6. <a class="reference external" href="https://doi.org/10.1090/gsm/020">doi:10.1090/gsm/020</a>.</p>
</div>
<div class="citation" id="id12" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GM21<span class="fn-bracket">]</span></span>
<p>Sergei Gukov and Ciprian Manolescu. A two-variable series for knot complements. <em>Quantum Topol.</em>, 12(1):1–109, 2021. <a class="reference external" href="https://doi.org/10.4171/qt/145">doi:10.4171/qt/145</a>.</p>
</div>
<div class="citation" id="id22" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GPP21<span class="fn-bracket">]</span></span>
<p>Sergei Gukov, Sunghyuk Park, and Pavel Putrov. Cobordism invariants from BPS q-series. In <em>Annales Henri Poincaré</em>, 1–31. Springer, 2021.</p>
</div>
<div class="citation" id="id13" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GPPV20<span class="fn-bracket">]</span></span>
<p>Sergei Gukov, Du Pei, Pavel Putrov, and Cumrun Vafa. BPS spectra and 3-manifold invariants. <em>J. Knot Theory Ramifications</em>, 29(2):2040003, 85, 2020. <a class="reference external" href="https://doi.org/10.1142/S0218216520400039">doi:10.1142/S0218216520400039</a>.</p>
</div>
<div class="citation" id="id14" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>GPV17<span class="fn-bracket">]</span></span>
<p>Sergei Gukov, Pavel Putrov, and Cumrun Vafa. Fivebranes and 3-manifold homology. <em>J. High Energy Phys.</em>, pages 071, front matter+80, 2017. <a class="reference external" href="https://doi.org/10.1007/JHEP07(2017)071">doi:10.1007/JHEP07(2017)071</a>.</p>
</div>
<div class="citation" id="id25" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HM17<span class="fn-bracket">]</span></span>
<p>Kristen Hendricks and Ciprian Manolescu. Involutive Heegaard Floer homology. <em>Duke Math. J.</em>, 166(7):1211–1299, 2017. <a class="reference external" href="https://doi.org/10.1215/00127094-3793141">doi:10.1215/00127094-3793141</a>.</p>
</div>
<div class="citation" id="id6" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Jon85<span class="fn-bracket">]</span></span>
<p>Vaughan F. R. Jones. A polynomial invariant for knots via von Neumann algebras. <em>Bull. Amer. Math. Soc. (N.S.)</em>, 12(1):103–111, 1985. <a class="reference external" href="https://doi.org/10.1090/S0273-0979-1985-15304-2">doi:10.1090/S0273-0979-1985-15304-2</a>.</p>
</div>
<div class="citation" id="id21" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>LZ99<span class="fn-bracket">]</span></span>
<p>Ruth Lawrence and Don Zagier. Modular forms and quantum invariants of 3-manifolds. <em>Asian Journal of Mathematics</em>, 3(1):93–108, 1999.</p>
</div>
<div class="citation" id="id15" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Neu81<span class="fn-bracket">]</span></span>
<p>Walter D. Neumann. A calculus for plumbing applied to the topology of complex surface singularities and degenerating complex curves. <em>Trans. Amer. Math. Soc.</em>, 268(2):299–344, 1981. <a class="reference external" href="https://doi.org/10.2307/1999331">doi:10.2307/1999331</a>.</p>
</div>
<div class="citation" id="id11" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Nem05<span class="fn-bracket">]</span></span>
<p>András Némethi. On the Ozsváth-Szabó invariant of negative definite plumbed 3-manifolds. <em>Geom. Topol.</em>, 9:991–1042, 2005. <a class="reference external" href="https://doi.org/10.2140/gt.2005.9.991">doi:10.2140/gt.2005.9.991</a>.</p>
</div>
<div class="citation" id="id10" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Nem08<span class="fn-bracket">]</span></span>
<p>András Némethi. Lattice cohomology of normal surface singularities. <em>Publ. Res. Inst. Math. Sci.</em>, 44(2):507–543, 2008. <a class="reference external" href="https://doi.org/10.2977/prims/1210167336">doi:10.2977/prims/1210167336</a>.</p>
</div>
<div class="citation" id="id23" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OzsvathSSzabo14a<span class="fn-bracket">]</span></span>
<p>Peter Ozsváth, András I. Stipsicz, and Zoltán Szabó. A spectral sequence on lattice homology. <em>Quantum Topol.</em>, 5(4):487–521, 2014. <a class="reference external" href="https://doi.org/10.4171/QT/56">doi:10.4171/QT/56</a>.</p>
</div>
<div class="citation" id="id27" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OzsvathSSzabo14b<span class="fn-bracket">]</span></span>
<p>Peter Ozsváth, András I. Stipsicz, and Zoltán Szabó. Knots in lattice homology. <em>Comment. Math. Helv.</em>, 89(4):783–818, 2014. <a class="reference external" href="https://doi.org/10.4171/CMH/334">doi:10.4171/CMH/334</a>.</p>
</div>
<div class="citation" id="id19" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OzsvathSzabo03<span class="fn-bracket">]</span></span>
<p>Peter Ozsváth and Zoltán Szabó. On the Floer homology of plumbed three-manifolds. <em>Geom. Topol.</em>, 7:185–224, 2003. <a class="reference external" href="https://doi.org/10.2140/gt.2003.7.185">doi:10.2140/gt.2003.7.185</a>.</p>
</div>
<div class="citation" id="id24" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OzsvathSzabo04a<span class="fn-bracket">]</span></span>
<p>Peter Ozsváth and Zoltán Szabó. Holomorphic disks and three-manifold invariants: properties and applications. <em>Ann. of Math. (2)</em>, 159(3):1159–1245, 2004. <a class="reference external" href="https://doi.org/10.4007/annals.2004.159.1159">doi:10.4007/annals.2004.159.1159</a>.</p>
</div>
<div class="citation" id="id18" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>OzsvathSzabo04b<span class="fn-bracket">]</span></span>
<p>Peter Ozsváth and Zoltán Szabó. Holomorphic disks and topological invariants for closed three-manifolds. <em>Ann. of Math. (2)</em>, 159(3):1027–1158, 2004. <a class="reference external" href="https://doi.org/10.4007/annals.2004.159.1027">doi:10.4007/annals.2004.159.1027</a>.</p>
</div>
<div class="citation" id="id9" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>RT91<span class="fn-bracket">]</span></span>
<p>N. Reshetikhin and V. G. Turaev. Invariants of 3-manifolds via link polynomials and quantum groups. <em>Invent. Math.</em>, 103(3):547–597, 1991. <a class="reference external" href="https://doi.org/10.1007/BF01239527">doi:10.1007/BF01239527</a>.</p>
</div>
<div class="citation" id="id7" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Wit89<span class="fn-bracket">]</span></span>
<p>Edward Witten. Quantum field theory and the Jones polynomial. <em>Comm. Math. Phys.</em>, 121(3):351–399, 1989.</p>
</div>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="plum.AdmissibleFamily">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">plum.</span></span><span class="sig-name descname"><span class="pre">AdmissibleFamily</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.AdmissibleFamily" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class to store and process a custom admissible family over the
rationals. In general, an admissible family can be defined over any
commutative ring with 1, however for now we only consider the rationals.
See <span id="id29">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span> for more details.</p>
<p>An admissible family is completely determined by an infinite sequence in
RxR, where R is the underlying ring (which in this setup we choose to be
the rationals). To compute the weighted graded root, zhat, or zhat_hat, of a
given plumbing with respect to some admissible family one really only needs
a finite sequence in RxR. Specifically, one needs a list of max_degree - 2
elements of RxR where max_degree is the maximum degree over all vertices in
the plumbing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values: list</strong></dt><dd><p>A list of the form [(a_i,b_i)] where a_i and b_i are rational numbers
specifiying that F_{i+3}(0) = a_i and F_{i+3}(1) = b_i.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>length</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>evaluation</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="plum.AdmissibleFamily.evaluation">
<span class="sig-name descname"><span class="pre">evaluation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.AdmissibleFamily.evaluation" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.AdmissibleFamily.length">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#plum.AdmissibleFamily.length" title="Permalink to this definition">#</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="plum.CustomVertex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">plum.</span></span><span class="sig-name descname"><span class="pre">CustomVertex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.CustomVertex" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>A class to allow for non-unique vertex labels for a sage Graph() object.</p>
<p>A vertex will be specified by a tuple v whose last entry is it’s label. The
subtuple v[:-1] must uniquely specify the vertex.</p>
<p class="rubric">Methods</p>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code>(value, /)</p></td>
<td><p>Return number of occurrences of value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code>(value[, start, stop])</p></td>
<td><p>Return first index of value.</p></td>
</tr>
</tbody>
</table>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="plum.Plumbing">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">plum.</span></span><span class="sig-name descname"><span class="pre">Plumbing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing" title="Permalink to this definition">#</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class for analyzing 3-manifolds plumbed along 2-spheres.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vertices_dict</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of the form {a:b} where a is the index of a vertex of the
plumbing and b is its corresponding weight.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">array_like</span></dt><dd><p>A list of the form [(a,b)] where (a,b) represents an edge between the
vertices of indicies a and b.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#plum.Plumbing.artin_fcycle" title="plum.Plumbing.artin_fcycle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">artin_fcycle</span></code></a></dt><dd><p>tuple: A tuple of the form (x, comp_seq) where x is the Artin</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.bad_vertices" title="plum.Plumbing.bad_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bad_vertices</span></code></a></dt><dd><p>tuple: A tuple of the form (bv, bv_count) where bv is a string</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.definiteness_type" title="plum.Plumbing.definiteness_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">definiteness_type</span></code></a></dt><dd><p>str: The definiteness type of the intersection form of the plumbing.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.degree_vector" title="plum.Plumbing.degree_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degree_vector</span></code></a></dt><dd><p>Matrix: An sx1 matrix of the form [[d_1],…,[d_s]] where d_i is the degree (or valence) of vertex i and s is the number of vertices of the plumbing.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.edge_count" title="plum.Plumbing.edge_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_count</span></code></a></dt><dd><p>int: The number of edges in the plumbing</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.homology" title="plum.Plumbing.homology"><code class="xref py py-obj docutils literal notranslate"><span class="pre">homology</span></code></a></dt><dd><p>tuple: A tuple of the form (homology_group, homology_generators,</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.intersection_form" title="plum.Plumbing.intersection_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection_form</span></code></a></dt><dd><p>Matrix: A matrix representing the intersection form of the plumbing.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.intersection_smith_form" title="plum.Plumbing.intersection_smith_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">intersection_smith_form</span></code></a></dt><dd><p>array_like: A list of the form D, U, V, where D is the smith normal</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.is_intersection_form_non_singular" title="plum.Plumbing.is_intersection_form_non_singular"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_intersection_form_non_singular</span></code></a></dt><dd><p>bool: True if the intersection form is non-singular, False otherwise.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.is_rational" title="plum.Plumbing.is_rational"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_rational</span></code></a></dt><dd><p>bool: True if the plumbing is rational, False or N/A otherwise.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.is_tree" title="plum.Plumbing.is_tree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_tree</span></code></a></dt><dd><p>bool: True if the plumbing diagram is a finite tree, False</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.is_weakly_elliptic" title="plum.Plumbing.is_weakly_elliptic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_weakly_elliptic</span></code></a></dt><dd><p>bool: True if the plumbing is weakly elliptic, False or N/A</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.max_degree" title="plum.Plumbing.max_degree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max_degree</span></code></a></dt><dd><p>int: the maximum degree over all vertices in the plumbing.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.vertex_count" title="plum.Plumbing.vertex_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vertex_count</span></code></a></dt><dd><p>int: The number of vertices in the plumbing.</p>
</dd>
<dt><a class="reference internal" href="#plum.Plumbing.weight_vector" title="plum.Plumbing.weight_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weight_vector</span></code></a></dt><dd><p>Matrix: An sx1 matrix of the form [[m_1],…,[m_s]] where m_i is the weight of vertex i and s is the number of vertices of the plumbing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.F" title="plum.Plumbing.F"><code class="xref py py-obj docutils literal notranslate"><span class="pre">F</span></code></a>(k, x[, A])</p></td>
<td><p>Given a vector k, lattice element x, and admissible family A, computes :math: <cite>F_{Gamma, k}(x)</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.char_vector_properties" title="plum.Plumbing.char_vector_properties"><code class="xref py py-obj docutils literal notranslate"><span class="pre">char_vector_properties</span></code></a>(k)</p></td>
<td><p>Given a characteristic vector k, compute some basic properties.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.chi" title="plum.Plumbing.chi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi</span></code></a>(k, x)</p></td>
<td><p>Given a vector k and a lattice point x (represented as a vector), compute chi_k(x) = -1/2(k(x) + (x,x)).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.chi_local_min_bounds" title="plum.Plumbing.chi_local_min_bounds"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi_local_min_bounds</span></code></a>(k)</p></td>
<td><p>Given a vector k, computes two lists [-chi_k(-e_1), ..., -chi_k(-e_s)] and [chi_k(e_1), ..., chi_k(e_s)] where e_i = (0, ..., 0, 1, 0, ..., 0) is the ith standard basis vector and s is the number of vertices of the plumbing.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.chi_local_min_set" title="plum.Plumbing.chi_local_min_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi_local_min_set</span></code></a>(k)</p></td>
<td><p>Given a vector k, computes the set of lattice points at which chi_k achieves a local min, when restricted to the lattice.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.chi_min" title="plum.Plumbing.chi_min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi_min</span></code></a>(k)</p></td>
<td><p>Given a vector k, computes the minimum of the function chi_k on Euclidean space and computes the vector which achieves this minimum.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.chi_sublevels" title="plum.Plumbing.chi_sublevels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chi_sublevels</span></code></a>(k, n)</p></td>
<td><p>Given a characteristic vector k and a positive integer n, this function computes the lattice points in each of the first n non-empty sublevel sets of chi_k.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.display" title="plum.Plumbing.display"><code class="xref py py-obj docutils literal notranslate"><span class="pre">display</span></code></a>()</p></td>
<td><p>Displays the plumbing graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.equiv_spinc_reps" title="plum.Plumbing.equiv_spinc_reps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equiv_spinc_reps</span></code></a>(k1, k2)</p></td>
<td><p>Given two characteristic vectors, check if they represent the same spin^c structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.is_almost_rational" title="plum.Plumbing.is_almost_rational"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_almost_rational</span></code></a>(test_threshold)</p></td>
<td><p>Tests if plumbing is almost rational.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.is_in_integer_image" title="plum.Plumbing.is_in_integer_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_in_integer_image</span></code></a>(k)</p></td>
<td><p>Given a vector k, check if it is in the integer image of the intersection form.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.weighted_graded_root" title="plum.Plumbing.weighted_graded_root"><code class="xref py py-obj docutils literal notranslate"><span class="pre">weighted_graded_root</span></code></a>(k, n[, A])</p></td>
<td><p>Given a characteristic vector k, a positive integer n, and an admissible family A, computes the first n levels of the weighted graded root corresponding to the admissible family.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#plum.Plumbing.zhat" title="plum.Plumbing.zhat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zhat</span></code></a>(s_rep, n, spinc_convention[, A])</p></td>
<td><p>Computes the generalized <span class="math notranslate nohighlight">\(\widehat{Z}\)</span> for the first n levels with respect to some admissible family A.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#plum.Plumbing.zhat_hat" title="plum.Plumbing.zhat_hat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zhat_hat</span></code></a>(s_rep, n, spinc_convention[, A])</p></td>
<td><p>Computes the generalized <span class="math notranslate nohighlight">\(\widehat{\widehat{Z}}\)</span> for the first n levels with respect to some admissible family A.</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.F">
<span class="sig-name descname"><span class="pre">F</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.F" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k, lattice element x, and admissible family A, computes
:math: <cite>F_{Gamma, k}(x)</cite>. See <span id="id30">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span> for more details. If no
admissible family is specified, then the admissible family used in the
computation is <span class="math notranslate nohighlight">\(\widehat{F}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [a_1, …, a_s] where s is the number of vertices
of the plumbing.</p>
</dd>
<dt><strong>x: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
of the plumbing.</p>
</dd>
<dt><strong>A: AdmissibleFamily</strong></dt><dd><p>An AdmissibleFamily object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>The value :math: <cite>F_{Gamma, k}(x)</cite></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.artin_fcycle">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">artin_fcycle</span></span><a class="headerlink" href="#plum.Plumbing.artin_fcycle" title="Permalink to this definition">#</a></dt>
<dd><p>tuple: A tuple of the form (x, comp_seq) where x is the Artin
fundamental cycle of the plumbing and comp_seq is the associated
computation sequence used to compute x. The Artin fundamental cycle is
used to determine the rationality of the plumbing graph. See
<span id="id31">[<a class="reference internal" href="#id11" title="András Némethi. On the Ozsváth-Szabó invariant of negative definite plumbed 3-manifolds. Geom. Topol., 9:991–1042, 2005. doi:10.2140/gt.2005.9.991.">Nem05</a>]</span> for more details about the Artin fundamental cycle.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.bad_vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bad_vertices</span></span><a class="headerlink" href="#plum.Plumbing.bad_vertices" title="Permalink to this definition">#</a></dt>
<dd><p>tuple: A tuple of the form (bv, bv_count) where bv is a string
listing the bad vertices, and bv_count is the number of bad vertices.
Recall a bad vertex is a vertex whose weight is greater than the
negative of its degree.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.char_vector_properties">
<span class="sig-name descname"><span class="pre">char_vector_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.char_vector_properties" title="Permalink to this definition">#</a></dt>
<dd><p>Given a characteristic vector k, compute some basic properties.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
of the plumbing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>(a,b,c, d) where: a is a string which says if the associated spin^c
structure on the plumbed 3-manifold is torsion or non-torsion, b is
the order of the 1st Chern class of the associated spin^c structure
on the plumbed 3-manifold, c is the square of the 1st Chern class of
the associated spin^c structure on the plumbed 4-manifold (in
other words, c = k^2), d is the t-variable normalization.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.chi">
<span class="sig-name descname"><span class="pre">chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.chi" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k and a lattice point x (represented as a vector),
compute chi_k(x) = -1/2(k(x) + (x,x)).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [a_1, …, a_s] where s is the number of vertices
of the plumbing.</p>
</dd>
<dt><strong>x: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
of the plumbing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>sage constant</dt><dd><p>The value of chi_k(x)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.chi_local_min_bounds">
<span class="sig-name descname"><span class="pre">chi_local_min_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.chi_local_min_bounds" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k, computes two lists [-chi_k(-e_1), …, -chi_k(-e_s)]
and [chi_k(e_1), …, chi_k(e_s)] where e_i = (0, …, 0, 1, 0, …, 0)
is the ith standard basis vector and s is the number of vertices of the
plumbing. For the purpose of this function, see the function
chi_local_min_set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [x_1, …, x_s].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>(a,b) where: a = [-chi_k(-e_1), …, -chi_k(-e_s)] and
b = [chi_k(e_1), …, chi_k(e_s)]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.chi_local_min_set">
<span class="sig-name descname"><span class="pre">chi_local_min_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.chi_local_min_set" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k, computes the set of lattice points at
which chi_k achieves a local min, when restricted to the lattice. In
other words, it computes the lattice points x such that
chi_k(x) &lt;= chi_k(x +/- e_i) for all i where
e_i = (0, …, 0, 1, 0, …, 0)  is the ith standard basis vector. Note
chi_k(x +/- e_i) = chi_k(x)+ chi_k(+/- e_i) -/+ (x, e_i). Hence, x is
in the min set iff -chi_k(-e_i) &lt;= (x, e_i) &lt;= chi_k(e_i) for all i.
This explains the reason for the helper function chi_local_min_bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
of the plumbing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>lists</dt><dd><p>Each element of the output list is a tuple (a, b, c) where a is
an element of the local min set, b is chi_k(a),
c = a dot (weight_vector + degree_vector).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.chi_min">
<span class="sig-name descname"><span class="pre">chi_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.chi_min" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k, computes the minimum of the function chi_k on
Euclidean space and computes the vector which achieves this minimum.
Note this vector, in general, need not be integral.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [a_1, …, a_s] where s is the number of vertices
of the plumbing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>(a,b) where: a is the minimum value of chi_k over R^s and b is a
list representing the unique vector which achieves this minimum.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.chi_sublevels">
<span class="sig-name descname"><span class="pre">chi_sublevels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.chi_sublevels" title="Permalink to this definition">#</a></dt>
<dd><p>Given a characteristic vector k and a positive integer n, this function
computes the lattice points in each of the first n non-empty sublevel
sets of chi_k. Also, computes chi_k(x) and
x dot (weight_vector + degree_vector) associated to each lattice
point x in each sublevel set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
in the plumbing.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>A positive integer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list</dt><dd><p>A list of the form [S_1, …, S_n] where S_i is the ith non-empty
sublevel set. Each S_i is a set whose elements are tuples of the
form (a, b, c) where a is a lattice point in S_i, b = chi_k(a),
c = a dot (weight_vector + degree_vector).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.definiteness_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">definiteness_type</span></span><a class="headerlink" href="#plum.Plumbing.definiteness_type" title="Permalink to this definition">#</a></dt>
<dd><p>str: The definiteness type of the intersection form of the plumbing.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Since the eigenvalues are computed numerically, they may contain small
error terms. Therefore, to check the sign of an eigenvalue, we have
chosen a small error threshold (1e-8). This potentially could lead to
incorrect answers in some edge cases when the true eigenvalues are very
close to zero, but non-zero.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.degree_vector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">degree_vector</span></span><a class="headerlink" href="#plum.Plumbing.degree_vector" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix: An sx1 matrix of the form [[d_1],…,[d_s]] where d_i is the
degree (or valence) of vertex i and s is the number of vertices of the
plumbing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.display">
<span class="sig-name descname"><span class="pre">display</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.display" title="Permalink to this definition">#</a></dt>
<dd><p>Displays the plumbing graph.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.edge_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edge_count</span></span><a class="headerlink" href="#plum.Plumbing.edge_count" title="Permalink to this definition">#</a></dt>
<dd><p>int: The number of edges in the plumbing</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.equiv_spinc_reps">
<span class="sig-name descname"><span class="pre">equiv_spinc_reps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.equiv_spinc_reps" title="Permalink to this definition">#</a></dt>
<dd><p>Given two characteristic vectors, check if they represent the same
spin^c structure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k1: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
of the plumbing.</p>
</dd>
<dt><strong>k2: list</strong></dt><dd><p>A list of integers [y_1, …, y_s] where s is the number of vertices
of the plumbing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if k1 and k2 represent the same spinc structure on the
plumbed 3-manifold, False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.homology">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">homology</span></span><a class="headerlink" href="#plum.Plumbing.homology" title="Permalink to this definition">#</a></dt>
<dd><p>tuple: A tuple of the form (homology_group, homology_generators,
rank) where homology_group is the first homology of the plumbed
3-manifold, homology generators are the corresponding generators of
homology_group, and rank is the Z-rank of the homology.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.intersection_form">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">intersection_form</span></span><a class="headerlink" href="#plum.Plumbing.intersection_form" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix: A matrix representing the intersection form of the
plumbing.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.intersection_smith_form">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">intersection_smith_form</span></span><a class="headerlink" href="#plum.Plumbing.intersection_smith_form" title="Permalink to this definition">#</a></dt>
<dd><p>array_like: A list of the form D, U, V, where D is the smith normal
form of the intersection form and where U and V are matrices such that
U*intersection_form*V = D.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.is_almost_rational">
<span class="sig-name descname"><span class="pre">is_almost_rational</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.is_almost_rational" title="Permalink to this definition">#</a></dt>
<dd><p>Tests if plumbing is almost rational.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>test_threshold: int</strong></dt><dd><p>A non-negative integer which is the amount by
which framings are decreased to test for rationality. See
<span id="id32">[<a class="reference internal" href="#id11" title="András Némethi. On the Ozsváth-Szabó invariant of negative definite plumbed 3-manifolds. Geom. Topol., 9:991–1042, 2005. doi:10.2140/gt.2005.9.991.">Nem05</a>]</span> for the definition of almost rational.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bool/str</dt><dd><p>True if plumbing is verfied to be almost rational given the
test threshold. False if determined to be not almost rational.
Otherwise, inconclusive given the choice of test threshold, or
not applicable if plumbing is not a negative definite tree.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.is_in_integer_image">
<span class="sig-name descname"><span class="pre">is_in_integer_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.is_in_integer_image" title="Permalink to this definition">#</a></dt>
<dd><p>Given a vector k, check if it is in the integer image of the
intersection form.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers of length = self.vertex_count.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if k is in the integer image of the intersection form, False
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.is_intersection_form_non_singular">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_intersection_form_non_singular</span></span><a class="headerlink" href="#plum.Plumbing.is_intersection_form_non_singular" title="Permalink to this definition">#</a></dt>
<dd><p>bool: True if the intersection form is non-singular, False otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.is_rational">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_rational</span></span><a class="headerlink" href="#plum.Plumbing.is_rational" title="Permalink to this definition">#</a></dt>
<dd><p>bool: True if the plumbing is rational, False or N/A otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.is_tree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_tree</span></span><a class="headerlink" href="#plum.Plumbing.is_tree" title="Permalink to this definition">#</a></dt>
<dd><p>bool: True if the plumbing diagram is a finite tree, False
otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.is_weakly_elliptic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_weakly_elliptic</span></span><a class="headerlink" href="#plum.Plumbing.is_weakly_elliptic" title="Permalink to this definition">#</a></dt>
<dd><p>bool: True if the plumbing is weakly elliptic, False or N/A
otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.max_degree">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_degree</span></span><a class="headerlink" href="#plum.Plumbing.max_degree" title="Permalink to this definition">#</a></dt>
<dd><p>int: the maximum degree over all vertices in the plumbing.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.vertex_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertex_count</span></span><a class="headerlink" href="#plum.Plumbing.vertex_count" title="Permalink to this definition">#</a></dt>
<dd><p>int: The number of vertices in the plumbing.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="plum.Plumbing.weight_vector">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weight_vector</span></span><a class="headerlink" href="#plum.Plumbing.weight_vector" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix: An sx1 matrix of the form [[m_1],…,[m_s]] where m_i is the
weight of vertex i and s is the number of vertices of the plumbing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.weighted_graded_root">
<span class="sig-name descname"><span class="pre">weighted_graded_root</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.weighted_graded_root" title="Permalink to this definition">#</a></dt>
<dd><p>Given a characteristic vector k, a positive integer n, and an admissible
family A, computes the first n levels of the weighted graded root
corresponding to the admissible family. If no admissible family is
specified, then the admissible family used in the computation is
<span class="math notranslate nohighlight">\(\widehat{F}\)</span>. See <span id="id33">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>k: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
in the plumbing. k should be a characteristic vector.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>A positive integer.</p>
</dd>
<dt><strong>A: AdmissibleFamily</strong></dt><dd><p>An AdmissibleFamily object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple</dt><dd><p>A tuple of the form (a, b) where a is a GraphPlot object
representing the weighted graded root and b is a list of the
two-variable weights of the vertices of the weighted graded root.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.zhat">
<span class="sig-name descname"><span class="pre">zhat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spinc_convention</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.zhat" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the generalized <span class="math notranslate nohighlight">\(\widehat{Z}\)</span> for the first n levels with
respect to some admissible family A. If no admissible family A is
specified then, it computes the usual zhat with respect to the
admissible family <span class="math notranslate nohighlight">\(\widehat{F}\)</span>. See <span id="id34">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span>
or <span id="id35">[<a class="reference internal" href="#id13" title="Sergei Gukov, Du Pei, Pavel Putrov, and Cumrun Vafa. BPS spectra and 3-manifold invariants. J. Knot Theory Ramifications, 29(2):2040003, 85, 2020. doi:10.1142/S0218216520400039.">GPPV20</a>]</span> for more details.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s_rep: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
in the plumbing.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>A positive integer.</p>
</dd>
<dt><strong>spinc_convention: int</strong></dt><dd><p>Either 0 or 1. If 0, then the vector s_rep should be congruent to
the weight vector mod 2. If 1, then the vector s_rep should be
congruent to the degree vector mod 2. The spinc_conventions 0 and 1
correspond to conventions (2) and (3) respectively in section 2 of
<span id="id36">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span> for representing spin^c structures.</p>
</dd>
<dt><strong>A: AdmissibleFamily</strong></dt><dd><p>An AdmissibleFamily object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt>Laurent polynomial:</dt><dd><p>A Laurent polynomial in q (except with the q variable
possibly assuming powers shifted by some overall rational number).
If <span class="math notranslate nohighlight">\(\widehat{Z} = a_{1}q^{\Delta + m} + a_{2}q^{\Delta + m +1} + \cdots + a_{n}q^{\Delta + m+n-1} + \cdots\)</span></p>
<p>where m is the minimum of <span class="math notranslate nohighlight">\(\chi_{k}\)</span> over the lattice, then
the output of this function is
<span class="math notranslate nohighlight">\(a_{1}q^{\Delta + m} + a_{2}q^{\Delta + m +1} + \cdots + a_{n}q^{\Delta + m+n-1}\)</span></p>
<p>Note, some <span class="math notranslate nohighlight">\(a_{i}\)</span> coefficients may be zero, in which case
it may appear that there are less than n terms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="plum.Plumbing.zhat_hat">
<span class="sig-name descname"><span class="pre">zhat_hat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s_rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spinc_convention</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#plum.Plumbing.zhat_hat" title="Permalink to this definition">#</a></dt>
<dd><p>Computes the generalized <span class="math notranslate nohighlight">\(\widehat{\widehat{Z}}\)</span> for the first n
levels with respect to some admissible family A. If no admissible family A is
specified then, it computes the usual zhat with respect to the
admissible family <span class="math notranslate nohighlight">\(\widehat{F}\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s_rep: list</strong></dt><dd><p>A list of integers [x_1, …, x_s] where s is the number of vertices
in the plumbing.</p>
</dd>
<dt><strong>n: int</strong></dt><dd><p>A positive integer.</p>
</dd>
<dt><strong>spinc_convention: int</strong></dt><dd><p>Either 0 or 1. If 0, then the vector s_rep should be congruent to
the weight vector mod 2. If 1, then the vector s_rep should be
congruent to the degree vector mod 2. The spinc_conventions 0 and 1
correspond to conventions (2) and (3) respectively in section 2 of
<span id="id37">[<a class="reference internal" href="#id28" title="Rostislav Akhmechet, Peter K Johnson, and Vyacheslav Krushkal. Lattice cohomology and q-series invariants of 3-manifolds. arXiv preprint arXiv:2109.14139, 2021.">AJK21</a>]</span> for representing spin^c structures.</p>
</dd>
<dt><strong>A: AdmissibleFamily</strong></dt><dd><p>An AdmissibleFamily object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt>two-variable laurent polynomial:</dt><dd><p>A Laurent polynomial in q with coefficients in Laurent polynomials
in t (except with the q variable
possibly assuming powers shifted by some overall rational number).
If <span class="math notranslate nohighlight">\(\widehat{\widehat{Z}} = p_{1}(t)q^{\Delta + m} + p_{2}(t)q^{\Delta + m +1} + \cdots + p_{n}(t)q^{\Delta + m+n-1} + \cdots\)</span></p>
<p>where m is the minimum of <span class="math notranslate nohighlight">\(\chi_{k}\)</span> over the lattice, then,
the output of this function is
<span class="math notranslate nohighlight">\(p_{1}(t)q^{\Delta + m} + p_{2}(t)q^{\Delta + m +1} + \cdots + p_{n}(t)q^{\Delta + m+n-1}\)</span></p>
<p>Note, some <span class="math notranslate nohighlight">\(p_{i}(t)\)</span> coefficients may be zero, in which case
it may appear that there are less than n terms.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="modules.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">plum</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2021, Peter K. Johnson
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">plum module</a><ul>
<li><a class="reference internal" href="#plum.AdmissibleFamily"><code class="docutils literal notranslate"><span class="pre">AdmissibleFamily</span></code></a><ul>
<li><a class="reference internal" href="#plum.AdmissibleFamily.evaluation"><code class="docutils literal notranslate"><span class="pre">AdmissibleFamily.evaluation()</span></code></a></li>
<li><a class="reference internal" href="#plum.AdmissibleFamily.length"><code class="docutils literal notranslate"><span class="pre">AdmissibleFamily.length</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#plum.CustomVertex"><code class="docutils literal notranslate"><span class="pre">CustomVertex</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing"><code class="docutils literal notranslate"><span class="pre">Plumbing</span></code></a><ul>
<li><a class="reference internal" href="#plum.Plumbing.F"><code class="docutils literal notranslate"><span class="pre">Plumbing.F()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.artin_fcycle"><code class="docutils literal notranslate"><span class="pre">Plumbing.artin_fcycle</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.bad_vertices"><code class="docutils literal notranslate"><span class="pre">Plumbing.bad_vertices</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.char_vector_properties"><code class="docutils literal notranslate"><span class="pre">Plumbing.char_vector_properties()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.chi"><code class="docutils literal notranslate"><span class="pre">Plumbing.chi()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.chi_local_min_bounds"><code class="docutils literal notranslate"><span class="pre">Plumbing.chi_local_min_bounds()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.chi_local_min_set"><code class="docutils literal notranslate"><span class="pre">Plumbing.chi_local_min_set()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.chi_min"><code class="docutils literal notranslate"><span class="pre">Plumbing.chi_min()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.chi_sublevels"><code class="docutils literal notranslate"><span class="pre">Plumbing.chi_sublevels()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.definiteness_type"><code class="docutils literal notranslate"><span class="pre">Plumbing.definiteness_type</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.degree_vector"><code class="docutils literal notranslate"><span class="pre">Plumbing.degree_vector</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.display"><code class="docutils literal notranslate"><span class="pre">Plumbing.display()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.edge_count"><code class="docutils literal notranslate"><span class="pre">Plumbing.edge_count</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.equiv_spinc_reps"><code class="docutils literal notranslate"><span class="pre">Plumbing.equiv_spinc_reps()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.homology"><code class="docutils literal notranslate"><span class="pre">Plumbing.homology</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.intersection_form"><code class="docutils literal notranslate"><span class="pre">Plumbing.intersection_form</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.intersection_smith_form"><code class="docutils literal notranslate"><span class="pre">Plumbing.intersection_smith_form</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_almost_rational"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_almost_rational()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_in_integer_image"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_in_integer_image()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_intersection_form_non_singular"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_intersection_form_non_singular</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_rational"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_rational</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_tree"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_tree</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.is_weakly_elliptic"><code class="docutils literal notranslate"><span class="pre">Plumbing.is_weakly_elliptic</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.max_degree"><code class="docutils literal notranslate"><span class="pre">Plumbing.max_degree</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.vertex_count"><code class="docutils literal notranslate"><span class="pre">Plumbing.vertex_count</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.weight_vector"><code class="docutils literal notranslate"><span class="pre">Plumbing.weight_vector</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.weighted_graded_root"><code class="docutils literal notranslate"><span class="pre">Plumbing.weighted_graded_root()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.zhat"><code class="docutils literal notranslate"><span class="pre">Plumbing.zhat()</span></code></a></li>
<li><a class="reference internal" href="#plum.Plumbing.zhat_hat"><code class="docutils literal notranslate"><span class="pre">Plumbing.zhat_hat()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>