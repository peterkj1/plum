"""A sage module for analyzing manifolds plumbed along 2-spheres.

This module enables the user to enter a plumbing diagram and return basic
information about the corresponding 3- and 4-dimensional manifolds,
for example the intersection form, homology, etc.

For negative definite plumbing trees equipped with a spin^c structure, the
program can also compute the weighted graded root :cite:p:`AJK`,
:math:`\widehat{Z}` invariant :cite:p:`GPPV`, and the
:math:`\widehat{\widehat{Z}}` invariant :cite:p:`AJK`.

.. bibliography::
   :all:

"""


# This file was *autogenerated* from the file plum.sage

#*****************************************************************************
#  Copyright (C) 2021 Peter K. Johnson <pkj4vj@virginia.edu>
#
#  Distributed under the terms of the GNU General Public License (GNU GPLv3)
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from copy import copy, deepcopy
from itertools import product, groupby

import math
import sys

class CustomVertex(tuple):
    """A class to allow for non-unique vertex labels for a sage Graph() object.

    A vertex will be specified by a tuple v whose last entry is it's label. The
    subtuple v[:-1] must uniquely specify the vertex.
    """
    def __init__(self, v):
        self.vertex = v

    def __str__(self):
        return str(self.vertex[-_sage_const_1 ])

class Plumbing:
    """A class for analyzing 3-manifolds plumbed along 2-spheres.

    Parameters
    ----------
    vertices_dict : dict
        A dictionary of the form {a:b} where a is the index of a vertex of the
        plumbing and b is its corresponding weight.
    edges : array_like
        A list of the form [(a,b)] where (a,b) represents an edge between the
        vertices of indicies a and b.

    Example
    -------
    >>> P = Plumbing({0:-1, 1:-2, 2:-3, 3:-7}, [(0,1), (0,2), (0,3)])

    Here P is the plumbing consisting of 4 vertices with weights
    -1, -2, -3, and -7 respectively. Vertices 0 and 1, 0 and 2, 0 and 3
    are connected by edges.

    """


    def __init__(self, vertices_dict, edges):
        try:
            self._vertices_dict = vertices_dict
            self._edges = edges

            self._vertex_count = len(vertices_dict)
            self._edge_count = len(edges)

            self._graph = Graph()
            self._vertex_list = ['$v_{' + str(i) + '}\\hspace{2} '
                                  + str(vertices_dict[i])
                                  + '$' for i in range(_sage_const_0 , self._vertex_count)]

            self._edge_list = [(self._vertex_list[x[_sage_const_0 ]], self._vertex_list[x[_sage_const_1 ]])
                               for x in edges]

            self._graph.add_vertices(self._vertex_list)
            self._graph.add_edges(self._edge_list)

            self._plot_options = options = {'vertex_color': 'black',
                                            'vertex_size': _sage_const_20 ,
                                            'layout': 'tree'}

            self._graph_plot = GraphPlot(self._graph, self._plot_options)

            self._weight_vector = Matrix(list(vertices_dict.values())).T
            self._degree_vector = [self._graph.degree(x) for x in
                                   self._vertex_list]
            self._degree_vector = Matrix(self._degree_vector).T

            self._intersection_form = None
            self._intersection_smith_form = None
            self._is_intersection_form_non_singular = None
            self._is_tree = None
            self._definiteness_type = None
            self._bad_vertices = None
            self._artin_fcycle = None
            self._is_weakly_elliptic = None
            self._is_rational = None
            self._is_almost_rational = None
            self._homology = None

        except:
            print("Error: Plumbing entered incorrectly. Please check input.")

    @property
    def vertex_count(self):
        """int: The number of vertices in the plumbing."""
        return self._vertex_count

    @property
    def edge_count(self):
        """int: The number of edges in the plumbing"""
        return self._edge_count

    @property
    def weight_vector(self):
        """Matrix: An sx1 matrix of the form [[m_1],...,[m_s]] where m_i is the
        weight of vertex i and s is the number of vertices of the plumbing."""
        return self._weight_vector

    @property
    def degree_vector(self):
        """Matrix: An sx1 matrix of the form [[d_1],...,[d_s]] where d_i is the
        degree (or valence) of vertex i and s is the number of vertices of the
        plumbing."""
        return self._degree_vector

    @property
    def intersection_form(self):
        """Matrix: A matrix representing the intersection form of the
        plumbing."""
        if self._intersection_form is None:
            intersection_form = self._graph.adjacency_matrix()
            for i in range(_sage_const_0 , self._vertex_count):
                intersection_form[i, i] = self._weight_vector[i,_sage_const_0 ]
            self._intersection_form = intersection_form
        return self._intersection_form

    @property
    def intersection_smith_form(self):
        """array_like: A list of the form D, U, V, where D is the smith normal
        form of the intersection form and where U and V are matrices such that
        U*intersection_form*V = D.
        """
        if self._intersection_smith_form is None:
            self._intersection_smith_form = self.intersection_form.smith_form()
        return self._intersection_smith_form

    @property
    def is_intersection_form_non_singular(self):
        "bool: True if the intersection form is non-singular, False otherwise."
        if self._is_intersection_form_non_singular is None:
            d = self.intersection_form.det()
            if d == _sage_const_0 :
                self._is_intersection_form_non_singular = False
            else:
                self._is_intersection_form_non_singular = True
        return self._is_intersection_form_non_singular

    @property
    def is_tree(self):
        """bool: True if the plumbing diagram is a finite tree, False
        otherwise."""
        if self._is_tree is None:
            self._is_tree = self._graph.is_tree()
        return self._is_tree

    @property
    def definiteness_type(self):
        """str: The definiteness type of the intersection form of the plumbing.

        Warnings
        --------
        Since the eigenvalues are computed numerically, they may contain small
        error terms. Therefore, to check the sign of an eigenvalue, we have
        chosen a small error threshold (1e-8). This potentially could lead to
        incorrect answers in some edge cases when the true eigenvalues are very
        close to zero, but non-zero.

        """
        if self._definiteness_type is None:
            eigenvalues = self.intersection_form.eigenvalues()
            if all(i < -_sage_const_1en8  for i in eigenvalues):
                self._definiteness_type = "negative definite"
            elif all(i > _sage_const_1en8  for i in eigenvalues):
                self._definiteness_type = "positive definite"
            elif all(i == _sage_const_0  for i in eigenvalues):
                self._definiteness_type = "zero matrix"
            elif all(i <= _sage_const_1en8  for i in eigenvalues):
                self._definiteness_type = "negative semi-definite"
            elif all(i >= -_sage_const_1en8  for i in eigenvalues):
                self._definiteness_type = "positive semi-definite"
            else:
                return "positive and negative eigenvalues"
        return self._definiteness_type

    @property
    def bad_vertices(self):
        """tuple: A tuple of the form (bv, bv_count) where bv is a string
        listing the bad vertices, and bv_count is the number of bad vertices.
        Recall a bad vertex is a vertex whose weight is greater than the
        negative of its degree.
        """
        if self._bad_vertices is None:
            bv_count = _sage_const_0
            bv = ''
            test = False
            for i in range(_sage_const_0 , self._vertex_count):
                if test and self._weight_vector[i,_sage_const_0 ] > -self._degree_vector[i,_sage_const_0 ]:
                    bv = bv + ", v_{"+str(i)+"}"
                    bv_count += _sage_const_1
                else:
                    if self._weight_vector[i,_sage_const_0 ] > -self._degree_vector[i,_sage_const_0 ]:
                        bv = ": v_{"+str(i)+"}"
                        bv_count += _sage_const_1
                        test = True
            if bv_count == _sage_const_0 :
                bv = '0 bad vertices.'
            elif bv_count == _sage_const_1 :
                bv = "1 bad vertex" + bv + "."
            else:
                bv = str(bv_count) + " bad vertices" + bv + "."
            self._bad_vertices = bv, bv_count
        return self._bad_vertices

    @property
    def artin_fcycle(self):
        """tuple: A tuple of the form (x, comp_seq) where x is the Artin
        fundamental cycle of the plumbing and comp_seq is the associated
        computation sequence used to compute x. The Artin fundamental cycle is
        used to determine the rationality of the plumbing graph. See
        :cite:p:`Nem_On_the` for more details about the Artin fundamental cycle.
        """
        if self._artin_fcycle is None and self.definiteness_type ==                "negative definite" and self.is_tree:
            x = [_sage_const_0 ] * self.vertex_count
            x[_sage_const_0 ] = _sage_const_1
            x = Matrix(x)
            z = x*self.intersection_form
            comp_seq = [deepcopy(x)]
            while any(i > _sage_const_0  for i in z.row(_sage_const_0 )):
                j = _sage_const_0
                while z[_sage_const_0 ,j] <= _sage_const_0 :
                    j = j + _sage_const_1
                x[_sage_const_0 ,j] = x[_sage_const_0 ,j] + _sage_const_1
                comp_seq.append(deepcopy(x))
                z = x * self.intersection_form
            self._artin_fcycle = x, comp_seq
        else:
            self._artin_fcycle = "Not applicable; plumbing is not a negative\
                                  definite tree."
        return self._artin_fcycle

    @property
    def is_weakly_elliptic(self):
        """bool: True if the plumbing is weakly elliptic, False or N/A
        otherwise.
        """
        if self._is_weakly_elliptic is None:
            if self.is_tree and self.definiteness_type == "negative definite":
                k = [-i-_sage_const_2  for i in self._graph.vs["v_weights"]]
                k = Matrix(k)
                m = -(k * self.artin_fcycle[_sage_const_0 ].T
                      + self.artin_fcycle[_sage_const_0 ]
                      * self.intersection_form
                      * self.artin_fcycle[_sage_const_0 ].T)[_sage_const_0 ,_sage_const_0 ] / _sage_const_2
                if m == _sage_const_0 :
                    self._is_weakly_elliptic = True
                    self._is_rational = False
                else:
                    self._is_weakly_elliptic = False
            else:
                self._is_weakly_elliptic = "Not applicable; plumbing is not a\
                                            negative definite tree."
        return self._is_weakly_elliptic

    @property
    def is_rational(self):
        """bool: True if the plumbing is rational, False or N/A otherwise."""
        if self._is_rational is None:
            if self.is_tree and self.definiteness_type == "negative definite":
                k = [-i-_sage_const_2  for i in self._graph.vs["v_weights"]]
                k = Matrix(k)
                m = -(k * self.artin_fcycle[_sage_const_0 ].T
                      + self.artin_fcycle[_sage_const_0 ]
                      * self.intersection_form
                      * self.artin_fcycle[_sage_const_0 ].T)[_sage_const_0 ,_sage_const_0 ] / _sage_const_2
                if m == _sage_const_1 :
                    self._is_rational = True
                    self._is_weakly_elliptic = False
                else:
                    self._is_rational = False
            else:
                self._is_rational = "Not applicable; plumbing is not a negative\
                                     definite tree."
        return self._is_rational

    @property
    def homology(self):
        """tuple: A tuple of the form (homology_group, homology_generators,
        rank) where homology_group is the first homology of the plumbed
        3-manifold, homology generators are the corresponding generators of
        homology_group, and rank is the Z-rank of the homology.
        """
        if self._homology is None:
            smith = self.intersection_smith_form
            D = smith[_sage_const_0 ]
            U = smith[_sage_const_1 ]
            U_inv = U.inverse()
            s = self.vertex_count
            rank = D.diagonal().count(_sage_const_0 )
            num_of_pivots = s - rank
            invariant_factors = [D[i,i] for i in range(_sage_const_0 , num_of_pivots)]
            p = invariant_factors.count(_sage_const_1 )
            invariant_factors = invariant_factors[p:]
            finite_ord_coker_gens = [U_inv[:, i] for i in range(p,
                                                                num_of_pivots)]
            infinite_ord_coker_gens = [U_inv[:, i] for i in range(num_of_pivots,
                                                                  s)]
            homology_generators = []
            if rank == _sage_const_0 :
                if len(invariant_factors) == _sage_const_0 :
                    homology_group = "0"
                    homology_generators.append("N/A")
                else:
                    homology_group = "Z_{" + str(invariant_factors[_sage_const_0 ]) + "}"
                    homology_generators.append(finite_ord_coker_gens[_sage_const_0 ])
                    for i in range(_sage_const_1 , len(invariant_factors)):
                        homology_group = homology_group + " + Z_{"                                         + str(invariant_factors[i]) + "}"
                        homology_generators.append(finite_ord_coker_gens[i])
            elif rank == _sage_const_1 :
                homology_group = "Z"
                homology_generators.append(infinite_ord_coker_gens[_sage_const_0 ])
                for i in range(_sage_const_0 , len(invariant_factors)):
                    homology_group = homology_group + " + Z_{"                                     + str(invariant_factors[i]) + "}"
                    homology_generators.append(finite_ord_coker_gens[i])
            else:
                homology_group = "Z^{" + str(rank) + "}"
                for i in range(_sage_const_0 , rank):
                    homology_generators = homology_generators.append(infinite_ord_coker_gens[i])
                for i in range(_sage_const_0 , len(invariant_factors)):
                    homology_group = homology_group + " + Z_{"                                     + str(invariant_factors[i]) + "}"
                    homology_generators.append(finite_ord_coker_gens[i])

            self._homology = homology_group, homology_generators, rank

        return self._homology

    def is_almost_rational(self, test_threshold):
        """Tests if plumbing is almost rational.

        Parameters
        ----------
        test_threshold: int
            A non-negative integer which is the amount by
            which framings are decreased to test for rationality. See
            :cite:p:`Nem_On_the` for the definition of almost rational.

        Returns
        -------
        bool/str
            True if plumbing is verfied to be almost rational given the
            test threshold. False if determined to be not almost rational.
            Otherwise, inconclusive given the choice of test threshold, or
            not applicable if plumbing is not a negative definite tree.
        """
        try:
            if (not test_threshold.is_integer()) or test_threshold < _sage_const_0 :
                raise Exception("Test threshold parameter must be a\
                                 non-negative integer.")
            if self._is_almost_rational is None:
                if self.is_tree and self.definiteness_type == "negative definite":
                    if self.bad_vertices[_sage_const_1 ] < _sage_const_2 :
                        self._is_almost_rational = True
                    elif self._is_rational or self._is_weakly_elliptic:
                        self._is_almost_rational = True
                    else:
                        very_bad_vert_count = _sage_const_0
                        for i in range(_sage_const_0 , self._vertex_count):
                            if -self._weight_vector[i,_sage_const_0 ]                                     <= self._degree_vector[i,_sage_const_0 ] - _sage_const_2 :
                                very_bad_vert_count = very_bad_vert_count + _sage_const_1
                        if very_bad_vert_count > _sage_const_1 :
                            self._is_almost_rational = False
                        else:
                            self._is_almost_rational = "inconclusive, using\
                                                        test threshold of " +                                                       str(test_threshold) +                                                       " try a larger test\
                                                       threshold."
                            counter = _sage_const_1
                            while counter <= test_threshold:
                                for i in range(_sage_const_0 , self._vertex_count):
                                    v = deepcopy(self._vertices_dict)
                                    v[i] = v[i] - counter
                                    plumb = Plumbing(v, self._edges)
                                    k = [-j-_sage_const_2  for j in v.values()]
                                    k = Matrix(k)
                                    m = -(k * plumb.artin_fcycle[_sage_const_0 ].T
                                          + plumb.artin_fcycle[_sage_const_0 ]
                                          * self.intersection_form
                                          * plumb.artin_fcycle[_sage_const_0 ].T)[_sage_const_0 ,_sage_const_0 ] / _sage_const_2
                                    if m == _sage_const_1 :
                                        self._is_almost_rational = True
                                        break
                                counter = counter + _sage_const_1
                else:
                    self._is_almost_rational = "Not applicable; plumbing is not\
                                                a negative definite tree."
            return self._is_almost_rational
        except Exception as e:
            print(e)

    def display(self):
        "Displays the plumbing graph."
        self._graph_plot.show()

    def is_in_integer_image(self, k):
        """Given a vector k, check if it is in the integer image of the
        intersection form.

        Parameters
        ----------
        k: list
            A list of integers of length = self.vertex_count.

        Returns
        -------
        bool
            True if k is in the integer image of the intersection form, False
            otherwise.

        """
        k = Matrix(k).T
        if self.is_intersection_form_non_singular:
            h = self.intersection_form.inverse()*k
            for x in h.column(_sage_const_0 ):
                if float(x) % _sage_const_1  != _sage_const_0 :
                    return False
            return True
        else:
            smith = self.intersection_smith_form
            D = smith[_sage_const_0 ]
            U = smith[_sage_const_1 ]
            num_of_pivots = self.vertex_count - D.diagonal().count(_sage_const_0 )
            j = U * k
            for i in range(_sage_const_0 , num_of_pivots):
                if float(j[i, _sage_const_0 ]) % float(D[i, i]) != _sage_const_0 :
                    return False
            for i in range(num_of_pivots, self.vertex_count):
                if float(j[i, _sage_const_0 ]) != _sage_const_0 :
                    return False
            return True

    def equiv_spinc_reps(self, k1, k2):
        """Given two characteristic vectors, check if they represent the same
        spin^c structure.

        Parameters
        ----------
        k1: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            of the plumbing.

        k2: list
            A list of integers [y_1, ..., y_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        bool
            True if k1 and k2 represent the same spinc structure on the
            plumbed 3-manifold, False otherwise.

        """

        try:
            k1 = Matrix(k1).T
            k2 = Matrix(k2).T
            for i in range(_sage_const_0 , self.vertex_count):
                if (float(k1[i, _sage_const_0 ])-float(self.weight_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                    raise Exception
                if (float(k2[i, _sage_const_0 ])-float(self.weight_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                    raise Exception
            k = (_sage_const_1 /_sage_const_2 )*(k1-k2)
            k = k.column(_sage_const_0 )
            return self.is_in_integer_image(k)
        except:
            print("Error: one or more of the inputs are not a characteristic "
                  "vector.")

    def char_vector_properties(self, k):
        """Given a characteristic vector k, compute some basic properties.

        Parameters
        ----------
        k: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        tuple
            (a,b,c) where: a is a string which says if the associated spin^c
            structure on the plumbed 3-manifold is torsion or non-torsion, b is
            the order of the 1st Chern class of the associated spin^c structure
            on the plumbed 3-manifold, c is the square of the 1st Chern class of
            the associated spin^c structure on the plumbed 4-manifold (in
            other words, c = k^2).

        """
        try:
            k = Matrix(k).T
            for i in range(_sage_const_0 , self.vertex_count):
                if (float(k[i, _sage_const_0 ])-float(self.weight_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                    raise Exception("Input is not a characteristic vector.")

            if self.is_intersection_form_non_singular:
                h = self.intersection_form.inverse()*k
                denominators_of_h_entries = [x.denominator() for x in
                                             h.column(_sage_const_0 )]
                order_of_chern_class = abs(lcm(denominators_of_h_entries))
                square = (k.T * h)[_sage_const_0 , _sage_const_0 ]
                return "Torsion", order_of_chern_class, square
            else:
                smith = self.intersection_smith_form
                D = smith[_sage_const_0 ]
                U = smith[_sage_const_1 ]
                V = smith[_sage_const_2 ]
                num_of_pivots = self.vertex_count - D.diagonal().count(_sage_const_0 )
                j = U * k

                for i in range(num_of_pivots, self.vertex_count):
                    if j[i, _sage_const_0 ] != _sage_const_0 :
                        return "Non-Torsion", "N/A", "N/A"

                h = self.vertex_count*[_sage_const_0 ]

                for i in range(_sage_const_0 , num_of_pivots):
                    h[i] = j[i, _sage_const_0 ]/D[i, i]

                denoms_of_non_zero_h_entries = [h[i].denominator() for i in
                                                range(_sage_const_0 , num_of_pivots)]

                order_of_chern_class = abs(lcm(denoms_of_non_zero_h_entries))
                h = V * Matrix(h).T
                square = (k.T * h)[_sage_const_0 ,_sage_const_0 ]
                return "Torsion", order_of_chern_class, square
        except Exception as e:
            print(e)

    def chi(self, k, x):
        """
        Given a vector k and a lattice point x (represented as a vector),
        compute chi_k(x) = -1/2(k(x) + (x,x)).

        Parameters
        ----------
        k: list
            A list of integers [a_1, ..., a_s] where s is the number of vertices
            of the plumbing.

        x: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        sage constant
            The value of chi_k(x)

        """

        k = Matrix(k)
        x = Matrix(x).T
        return -(_sage_const_1 /_sage_const_2 )*(k * x + x.T * self.intersection_form * x)[_sage_const_0 ,_sage_const_0 ]

    def chi_min(self, k):
        """
        Given a vector k, computes the minimum of the function chi_k on
        Euclidean space and computes the vector which achieves this minimum.
        Note this vector, in general, need not be integral.

        Parameters
        ----------
        k: list
            A list of integers [a_1, ..., a_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        tuple
            (a,b) where: a is the minimum value of chi_k over R^s and b is a
            list representing the unique vector which achieves this minimum.

        """
        if self.definiteness_type == "negative definite":
            chi_min = self.char_vector_properties(k)[_sage_const_2 ]/_sage_const_8
            k = Matrix(k).T
            chi_min_vector = -(_sage_const_1 /_sage_const_2 ) * self.intersection_form.inverse() * k
            return chi_min, list(chi_min_vector.column(_sage_const_0 ))
        else:
            return "Only implemented for negative definite plumbings."

    def F_hat(self, k, x):
        """
        Given a vector k and a lattice element x, computes
        :math: `\widehat{F}_{\Gamma, k}(x)`. See :cite:p:`AJK` for more details.

        Parameters
        ----------
        k: list
            A list of integers [a_1, ..., a_s] where s is the number of vertices
            of the plumbing.
        x: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        int
            The value :math: `\widehat{F}_{\Gamma, k}(x)`

        """
        k = Matrix(k).T
        x = Matrix(x).T
        y = _sage_const_2 *self.intersection_form*x + k - self.weight_vector                                           - self.degree_vector
        F = _sage_const_1
        for i in range(_sage_const_0 , self.vertex_count):
            if self.degree_vector[i,_sage_const_0 ] == _sage_const_0 :
                if y[i, _sage_const_0 ] == _sage_const_0 :
                    F = -_sage_const_2 *F
                elif y[i, _sage_const_0 ] != _sage_const_2  and y[i, _sage_const_0 ]!= -_sage_const_2 :
                    F = _sage_const_0
                    return F
            elif self.degree_vector[i,_sage_const_0 ] == _sage_const_1 :
                if y[i, _sage_const_0 ] == _sage_const_1 :
                    F = -F
                elif y[i, _sage_const_0 ] != -_sage_const_1 :
                    F = _sage_const_0
                    return F
            elif self.degree_vector[i, _sage_const_0 ] == _sage_const_2 :
                if y[i, _sage_const_0 ] != _sage_const_0 :
                    F = _sage_const_0
                    return F
            else:
                if abs(y[i, _sage_const_0 ]) >= self.degree_vector[i, _sage_const_0 ]-_sage_const_2 :
                    F = F*(_sage_const_1 /_sage_const_2 )*sign(y[i,_sage_const_0 ])**(self.degree_vector[i, _sage_const_0 ])
                    F = F*binomial((self.degree_vector[i, _sage_const_0 ]
                                    + abs(y[i, _sage_const_0 ]))/_sage_const_2 -_sage_const_2 ,
                                    self.degree_vector[i, _sage_const_0 ] -_sage_const_3 )
                else:
                    F = _sage_const_0
                    return F
        return F

    def chi_local_min_bounds(self, k):
        """
        Given a vector k, computes two lists [-chi_k(-e_1), ..., -chi_k(-e_s)]
        and [chi_k(e_1), ..., chi_k(e_s)] where e_i = (0, ..., 0, 1, 0, ..., 0)
        is the ith standard basis vector and s is the number of vertices of the
        plumbing. For the purpose of this function, see the function
        chi_local_min_set.

        Parameters
        ----------
        k: list
            A list of integers [x_1, ..., x_s].

        Returns
        -------
        tuple
            (a,b) where: a = [-chi_k(-e_1), ..., -chi_k(-e_s)] and
            b = [chi_k(e_1), ..., chi_k(e_s)]

        """
        I = Matrix.identity(self.vertex_count)
        negative_I = -I
        positive_basis = [I.row(i) for i in range(_sage_const_0 , self.vertex_count)]
        negative_basis = [negative_I.row(i) for i in
                          range(_sage_const_0 , self.vertex_count)]
        chi_upper = [self.chi(k, x) for x in positive_basis]
        chi_lower = [-self.chi(k, x) for x in negative_basis]
        return chi_lower, chi_upper

    def chi_local_min_set(self, k):
        """
        Given a vector k, computes the set of lattice points at
        which chi_k achieves a local min, when restricted to the lattice. In
        other words, it computes the lattice points x such that
        chi_k(x) <= chi_k(x +/- e_i) for all i where
        e_i = (0, ..., 0, 1, 0, ..., 0)  is the ith standard basis vector. Note
        chi_k(x +/- e_i) = chi_k(x)+ chi_k(+/- e_i) -/+ (x, e_i). Hence, x is
        in the min set iff -chi_k(-e_i) <= (x, e_i) <= chi_k(e_i) for all i.
        This explains the reason for the helper function chi_local_min_bounds.

        Parameters
        ----------
        k: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            of the plumbing.

        Returns
        -------
        lists
            Each element of the output list is a tuple (a, b, c, d) where a is
            an element of the local min set, b is chi_k(a), c = F_hat(a),
            d = a dot (weight_vector + degree_vector).
        """
        if self.definiteness_type == "negative definite" and self.is_tree:
            bounds = self.chi_local_min_bounds(k)
            M_inv = self.intersection_form.inverse()
            iterator = [range(bounds[_sage_const_0 ][i], bounds[_sage_const_1 ][i]+_sage_const_1 ) for i in
                        range(_sage_const_0 , self.vertex_count)]
            iterator = product(*iterator)
            lms = []
            for x in iterator:
                y = M_inv*Matrix(x).T
                if y in MatrixSpace(ZZ, self.vertex_count, _sage_const_1 ):
                    u = tuple(y.column(_sage_const_0 ))
                    pairing = (Matrix(u)*(self.weight_vector
                               + self.degree_vector))[_sage_const_0 ,_sage_const_0 ]
                    lms.append((u,self.chi(k, u), self.F_hat(k, u), pairing))
            lms.sort(key = lambda x:x[_sage_const_1 ])
            return lms
        else:
            print("Only implemented for negative definite plumbing trees")


    def chi_sublevels(self, k, n):
        """
        Given a characteristic vector k and a positive integer n, this function
        computes the lattice points in each of the first n non-empty sublevel
        sets of chi_k. Also, computes chi_k(x), F_hat(x), and,
        x dot (weight_vector + degree_vector) associated to each lattice
        point x in each sublevel set.

        Parameters
        ----------
        k: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            in the plumbing.

        n: int
            A positive integer.

        Returns
        -------
        list
            A list of the form [S_1, ..., S_n] where S_i is the ith non-empty
            sublevel set. Each S_i is a set whose elements are tuples of the
            form (a, b, c, d) where a is a lattice point in S_i, b = chi_k(a),
            c = F(a), and d = a dot (weight_vector + degree_vector).

        """
        try:
            if (not n.is_integer()) or n < _sage_const_1 :
                raise Exception("Second parameter must be a postive integer.")
            if self.definiteness_type == "negative definite" and self.is_tree:
                lms = self.chi_local_min_set(k)

                groups = groupby(lms, operator.itemgetter(_sage_const_1 ))
                lms_partition = [tuple(group) for key, group in groups]

                min_level = lms_partition[_sage_const_0 ][_sage_const_0 ][_sage_const_1 ]
                sublevels = [set(lms_partition[_sage_const_0 ])]

                for i in range(_sage_const_1 , n):
                    sublevel_height = i + min_level
                    sublevel_temp1 = copy(sublevels[-_sage_const_1 ])
                    sublevel_temp2 = copy(sublevels[-_sage_const_1 ])
                    for x in sublevel_temp1:
                        for j in range(_sage_const_0 , self.vertex_count):
                            y = list(x[_sage_const_0 ])
                            z = list(x[_sage_const_0 ])
                            y[j] = y[j]-_sage_const_1
                            z[j] = z[j]+_sage_const_1
                            if self.chi(k, y) == sublevel_height:
                                pairing = (Matrix(y)*(self.weight_vector
                                           + self.degree_vector))[_sage_const_0 ,_sage_const_0 ]
                                sublevel_temp2.add((tuple(y), sublevel_height,
                                                    self.F_hat(k, tuple(y)),
                                                    pairing))
                            if self.chi(k, z) == sublevel_height:
                                pairing = (Matrix(z)*(self.weight_vector
                                           + self.degree_vector))[_sage_const_0 ,_sage_const_0 ]
                                sublevel_temp2.add((tuple(z), sublevel_height,
                                                    self.F_hat(k, tuple(z)),
                                                    pairing))
                    for u in lms_partition:
                        if u[_sage_const_0 ][_sage_const_1 ] == sublevel_height:
                            sublevel_temp2 = sublevel_temp2.union(set(u))
                            break
                    sublevels.append(sublevel_temp2)

                return sublevels

            else:
                print("Only implemented for negative definite plumbing trees.")
        except Exception as e:
            print(e)

    def weighted_graded_root(self, k, n):
        """
        Given a characteristic vector k and a positive integer n, computes
        the first n levels of the weighted graded root corresponding to the
        admissible family :math:`\widehat{F}`. See :cite:p:`AJK` for details.

        Parameters
        ----------
        k: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            in the plumbing. k should be a characteristic vector.

        n: int
            A positive integer.

        Returns
        -------
        tuple
            A tuple of the form (a, b) where a is a GraphPlot object
            representing the weighted graded root and b is a list of the
            two-variable weights of the vertices of the weighted graded root.

        """
        if self.definiteness_type == "negative definite" and self.is_tree:
            sublevels = self.chi_sublevels(k, n)

            k_squared = self.char_vector_properties(k)[_sage_const_2 ]

            for element in sublevels[_sage_const_0 ]:
                break
            min_chi_level = element[_sage_const_1 ]
            d_inv = -_sage_const_2 *(min_chi_level) + self.vertex_count/_sage_const_4                     + k_squared/_sage_const_4
            normalization_term = -(k_squared + _sage_const_3 *self.vertex_count
                                   + sum(self.weight_vector)[_sage_const_0 ])/_sage_const_4  + sum(k)/_sage_const_2                                    - sum(self.weight_vector + self.degree_vector)[_sage_const_0 ]/_sage_const_4

            top_sublevel = list(sublevels[-_sage_const_1 ])
            top_sublevel.sort()
            vertices = [list(w[_sage_const_0 ]) for w in top_sublevel]
            num_of_vertices = len(vertices)

            top_sublevel_graph = Graph(num_of_vertices)

            ts_edges = []
            for i in range(_sage_const_1 , num_of_vertices):
                for j in range(_sage_const_0 , self.vertex_count):
                    x = copy(vertices[i])
                    x[j] = x[j] - _sage_const_1
                    y = copy(vertices[i])
                    y[j] = y[j] + _sage_const_1
                    if x in vertices[:i]:
                        ts_edges.append((vertices[:i].index(x), i))
                    if y in vertices[:i]:
                        ts_edges.append((vertices[:i].index(y), i))

            top_sublevel_graph.add_edges(ts_edges)

            sublevel_graphs = []
            for sl in sublevels[:-_sage_const_1 ]:
                v_list = [top_sublevel.index(x) for x in sl]
                sublevel_graphs.append(top_sublevel_graph.subgraph(v_list))

            sublevel_graphs.append(top_sublevel_graph)

            connected_components = []
            for g in sublevel_graphs:
                connected_components.append(g.connected_components())

            bgr_vertices = []
            bgr_vertex_two_variable_weights = []
            index = _sage_const_0
            h_index = _sage_const_0
            v_index = _sage_const_0
            h_index_dictionary = {}
            T = LaurentPolynomialRing(QQ, names=('t',)); (t,) = T._first_ngens(1)
            Q = PuiseuxSeriesRing(T, names=('q',)); (q,) = Q._first_ngens(1)
            for x in connected_components:
                for y in x:
                    two_vpoly = _sage_const_0
                    for z in y:
                        w = top_sublevel[z]
                        two_vpoly = two_vpoly                                    + (w[_sage_const_2 ])*q**(_sage_const_2 *(w[_sage_const_1 ]) + w[_sage_const_3 ])*t**(w[_sage_const_3 ])
                    bgr_vertex_two_variable_weights.append(two_vpoly)
                    bgr_vertices.append((h_index, v_index, y[_sage_const_0 ], '$\\hspace{4}'
                                         + str(latex(d_inv + _sage_const_2 *v_index))
                                         + ': P_{'
                                         + str(index) + '}$'))

                    h_index = h_index + _sage_const_1
                    index = index + _sage_const_1
                h_index_dictionary[v_index] = h_index
                h_index = _sage_const_0
                v_index = v_index + _sage_const_1

            bgr = Graph()
            bgr.add_vertices(bgr_vertices)

            bgr_edges = []
            for x in bgr_vertices:
                if x[_sage_const_1 ]< v_index-_sage_const_1 :
                    for i in range(_sage_const_0 , h_index_dictionary[x[_sage_const_1 ]+_sage_const_1 ]):
                        if x[_sage_const_2 ] in connected_components[x[_sage_const_1 ]+_sage_const_1 ][i]:
                            ind = sum([h_index_dictionary[i] for
                                          i in range(_sage_const_0 ,x[_sage_const_1 ]+_sage_const_1 )]) + i
                            bgr_edges.append((x, bgr_vertices[ind]))
                            break
            bgr.add_edges(bgr_edges)

            bgr = Graph([(CustomVertex(a), CustomVertex(b)) for (a, b) in
                         bgr.edges(labels=False)])

            options = {'layout': 'forest',
                       'forest_roots': bgr_vertices[-h_index_dictionary[v_index-_sage_const_1 ]:],
                       'vertex_color': 'black', 'vertex_size': _sage_const_20 }

            bgr_plot = GraphPlot(bgr, options)

            for i in range(_sage_const_0 , index):
                bgr_vertex_two_variable_weights[i] = q**(normalization_term)*(bgr_vertex_two_variable_weights[i])

            bgr_plot.show()

            for i in range(_sage_const_0 , index):
                print('P_{' + str(i) + '} = '
                               + str(bgr_vertex_two_variable_weights[i]))
                print('\n')

            return bgr_plot, bgr_vertex_two_variable_weights

        else:
            print("Only implemented for negative definite plumbings trees.")

    def zhat_hat(self, s_rep, n, spinc_convention):
        """
        Computes :math:`\widehat{\widehat{Z}}` for the first n levels. Note
        zhat_hat is only well-defined up to multiplication by an overall power
        of t. There is a way to normalize the t power to eliminate this
        t-ambiguity, however this function does not do this.
        See :cite:p:`AJK` for more details.

        Parameters
        ----------
        s_rep: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            in the plumbing.

        n: int
            A positive integer.

        spinc_convention: int
            Either 0 or 1. If 0, then the vector s_rep should be congruent to
            the weight vector mod 2. If 1, then the vector s_rep should be
            congruent to the degree vector mod 2. The spinc_conventions 0 and 1
            correspond to conventions (2) and (3) respectively in section 2 of
            :cite:p:`AJK` for representing spin^c structures.

        Returns
        -------
        two-variable laurent polynomial:
            A Laurent polynomial in q with coefficients in Laurent polynomials
            in t (except with the q variable
            possibly assuming powers shifted by some overall rational number).
            If
            .. math::
                \widehat{\widehat{Z}} = p_{1}(t)q^{\Delta + m} + p_{2}(t)q^{\Delta + m +1} + \cdots + p_{n}(t)q^{\Delta + m+n-1} + \cdots
            where
            .. math::
                m = \ceil{\min_{x\in \mathbb{R}^s}2\chi_{k}(x) + \langle x, u\rangle}

            Then, the output of this function is
            .. math::
                p_{1}(t)q^{\Delta + m} + p_{2}(t)q^{\Delta + m +1} + \cdots + p_{n}(t)q^{\Delta + m+n-1}
            Note, some :math:`p_{i}` coefficients may be zero, in which case
            it may appear that there are less than n terms.
        """
        try:
            if (not n.is_integer()) or n < _sage_const_1 :
                raise Exception("Second parameter must be a postive integer.")
            if (spinc_convention != _sage_const_0 ) and (spinc_convention != _sage_const_1 ):
                raise Exception("Third parameter must be 0 or 1.")
            s_rep = Matrix(s_rep).T
            if spinc_convention == _sage_const_0 :
                for i in range(_sage_const_0 , self.vertex_count):
                    if (float(s_rep[i,_sage_const_0 ])-float(self.weight_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                        raise Exception("Your selected spin^c convention is to\
                                        use characteristic vectors, but second\
                                        parameter is not characteristic.")
                k = s_rep
                a = s_rep - self.weight_vector - self.degree_vector
            if spinc_convention == _sage_const_1 :
                for i in range(_sage_const_0 , self.vertex_count):
                    if (float(s_rep[i,_sage_const_0 ])-float(self.degree_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                        raise Exception("Your selected spin^c convention is to\
                                        use vectors congruent mod 2 to the\
                                        degree vector, but second parameter\
                                        does not satisfy this.")
                k = s_rep + self.weight_vector + self.degree_vector
                a = s_rep

            k_squared = self.char_vector_properties(k.T)[_sage_const_2 ]

            normalization_term = -(k_squared + _sage_const_3 *self.vertex_count
                                   + sum(self.weight_vector)[_sage_const_0 ])/_sage_const_4                                    + sum(k)[_sage_const_0 ]/_sage_const_2                                    - sum(self.weight_vector + self.degree_vector)[_sage_const_0 ]/_sage_const_4
            M = self.intersection_form
            M_inv = M.inverse()

            min_vector = -(_sage_const_1 /_sage_const_2 )*M_inv*a
            min_level = ((a.T*M_inv*a)[_sage_const_0 ,_sage_const_0 ])/_sage_const_4

            bounding_box = []
            for i in range(_sage_const_0 , self.vertex_count):
                if min_level % _sage_const_1  == _sage_const_0 :
                    x = _sage_const_2 *math.sqrt(-(self.weight_vector[i, _sage_const_0 ])*(n-_sage_const_1 ))
                else:
                    x = _sage_const_2 *math.sqrt(-(self.weight_vector[i, _sage_const_0 ])*n)
                bounding_box.append([-x, x])

            F_supp = []
            for i in range(_sage_const_0 , self.vertex_count):
                if self.degree_vector[i, _sage_const_0 ] == _sage_const_0 :
                    if bounding_box[i][_sage_const_0 ]<= -_sage_const_2  and bounding_box[i][_sage_const_1 ]>= _sage_const_2 :
                        F_supp.append([-_sage_const_2 , _sage_const_0 , _sage_const_2 ])
                    elif bounding_box[i][_sage_const_0 ]<= -_sage_const_2  and bounding_box[i][_sage_const_1 ]< _sage_const_2 :
                        F_supp.append([-_sage_const_2 , _sage_const_0 ])
                    elif bounding_box[i][_sage_const_0 ]> -_sage_const_2  and bounding_box[i][_sage_const_1 ]>= _sage_const_2 :
                        F_supp.append([_sage_const_0 , _sage_const_2 ])
                    else:
                        F_supp.append([_sage_const_0 ])
                elif self.degree_vector[i, _sage_const_0 ] == _sage_const_1 :
                    if bounding_box[i][_sage_const_0 ]<= -_sage_const_1  and bounding_box[i][_sage_const_1 ]>= _sage_const_1 :
                        F_supp.append([-_sage_const_1 , _sage_const_1 ])
                    elif bounding_box[i][_sage_const_0 ]<= -_sage_const_1  and bounding_box[i][_sage_const_1 ]<_sage_const_1 :
                        F_supp.append([-_sage_const_1 ])
                    elif bounding_box[i][_sage_const_0 ]> -_sage_const_1  and bounding_box[i][_sage_const_1 ]>=_sage_const_1 :
                        F_supp.append([_sage_const_1 ])
                    else:
                        return _sage_const_0
                elif self.degree_vector[i, _sage_const_0 ] == _sage_const_2 :
                    F_supp.append([_sage_const_0 ])
                else:
                    r = self.degree_vector[i, _sage_const_0 ]-_sage_const_2
                    values = []
                    if bounding_box[i][_sage_const_0 ] <=-r:
                        values.append(-r)
                        for j in range(_sage_const_1 , floor((-r-bounding_box[i][_sage_const_0 ])/_sage_const_2 )+_sage_const_1 ):
                            values.append(-r - _sage_const_2 *j)
                    if bounding_box[i][_sage_const_1 ] >=r:
                        values.append(r)
                        for j in range(_sage_const_1 , floor((bounding_box[i][_sage_const_1 ]-r)/_sage_const_2 )+_sage_const_1 ):
                            values.append(r + _sage_const_2 *j)
                    if len(values)==_sage_const_0 :
                        return _sage_const_0
                    F_supp.append(copy(values))
            iterator = product(*F_supp)

            def F_hat_pre_comp(y):
                F = _sage_const_1
                for i in range(_sage_const_0 , self.vertex_count):
                    if self.degree_vector[i, _sage_const_0 ] == _sage_const_0 :
                        if y[i, _sage_const_0 ] == _sage_const_0 :
                            F = -_sage_const_2 *F
                        elif y[i, _sage_const_0 ] != _sage_const_2  and y[i, _sage_const_0 ]!= -_sage_const_2 :
                            F = _sage_const_0
                            return F
                    elif self.degree_vector[i, _sage_const_0 ] == _sage_const_1 :
                        if y[i, _sage_const_0 ] == _sage_const_1 :
                            F = -F
                        elif y[i, _sage_const_0 ] != -_sage_const_1 :
                            F = _sage_const_0
                            return F
                    elif self.degree_vector[i, _sage_const_0 ] == _sage_const_2 :
                        if y[i, _sage_const_0 ] != _sage_const_0 :
                            F = _sage_const_0
                            return F
                    else:
                        if abs(y[i, _sage_const_0 ]) >= self.degree_vector[i, _sage_const_0 ]-_sage_const_2 :
                            F = F*(_sage_const_1 /_sage_const_2 )*sign(y[i,_sage_const_0 ])**(self.degree_vector[i, _sage_const_0 ])
                            F = F*binomial((self.degree_vector[i, _sage_const_0 ]
                                            + abs(y[i, _sage_const_0 ]))/_sage_const_2 -_sage_const_2 ,
                                            self.degree_vector[i, _sage_const_0 ] -_sage_const_3 )
                        else:
                            F = _sage_const_0
                            return F
                return F

            exponents = [ceil(min_level) + i for i in range(_sage_const_0 , n)]
            coefficients = n*[_sage_const_0 ]

            T = LaurentPolynomialRing(QQ, names=('t',)); (t,) = T._first_ngens(1)
            Q = PuiseuxSeriesRing(T, names=('q',)); (q,) = Q._first_ngens(1)

            for y in iterator:
                y = Matrix(y).T
                c = -((y.T*M_inv*y)[_sage_const_0 ,_sage_const_0 ])/_sage_const_4
                if frac(min_level) == _sage_const_0 :
                    if c <= n-_sage_const_1 :
                        x = (_sage_const_1 /_sage_const_2 )*M_inv*(y-a)
                        if x in MatrixSpace(ZZ, self.vertex_count, _sage_const_1 ):
                            ind = c
                            t_exp = (x.T*(self.weight_vector + self.degree_vector))[_sage_const_0 ,_sage_const_0 ]
                            coefficients[ind] = coefficients[ind] + F_hat_pre_comp(y)*t**(t_exp)
                else:
                    if c <= n:
                        x = (_sage_const_1 /_sage_const_2 )*M_inv*(y-a)
                        if x in MatrixSpace(ZZ, self.vertex_count, _sage_const_1 ):
                            ind = floor(c)
                            t_exp = (x.T*(self.weight_vector + self.degree_vector))[_sage_const_0 ,_sage_const_0 ]
                            coefficients[ind] = coefficients[ind] + F_hat_pre_comp(y)*t**(t_exp)

            zhat_hat_list = [(coefficients[i], exponents[i] + normalization_term) for i in range(_sage_const_0 , n)]

            truncated_zhat_hat = _sage_const_0
            for x in zhat_hat_list:
                truncated_zhat_hat = truncated_zhat_hat + x[_sage_const_0 ]*q**(x[_sage_const_1 ])
            return truncated_zhat_hat

        except Exception as e:
            print(e)

    def zhat(self, s_rep, n, spinc_convention):
        """
        Computes :math:`\widehat{Z}` for the first n levels. See :cite:p:`AJK`
        or :cite:p:`GPPV` for more details.

        Parameters
        ----------
        s_rep: list
            A list of integers [x_1, ..., x_s] where s is the number of vertices
            in the plumbing.

        n: int
            A positive integer.

        spinc_convention: int
            Either 0 or 1. If 0, then the vector s_rep should be congruent to
            the weight vector mod 2. If 1, then the vector s_rep should be
            congruent to the degree vector mod 2. The spinc_conventions 0 and 1
            correspond to conventions (2) and (3) respectively in section 2 of
            :cite:p:`AJK` for representing spin^c structures.

        Returns
        -------
        Laurent polynomial:
            A Laurent polynomial in q (except with the q variable
            possibly assuming powers shifted by some overall rational number).
            If
            .. math::
                \widehat{Z} = a_{1}q^{\Delta + m} + a_{2}q^{\Delta + m +1} + \cdots + a_{n}q^{\Delta + m+n-1} + \cdots
            where
            .. math::
                m = \ceil{\min_{x\in \mathbb{R}^s}2\chi_{k}(x) + \langle x, u\rangle}

            Then, the output of this function is
            .. math::
                a_{1}q^{\Delta + m} + a_{2}q^{\Delta + m +1} + \cdots + a_{n}q^{\Delta + m+n-1}
            Note, some :math:`a_{i}` coefficients may be zero, in which case
            it may appear that there are less than n terms.
        """
        try:
            if (not n.is_integer()) or n < _sage_const_1 :
                raise Exception("Second parameter must be a postive integer.")
            if (spinc_convention != _sage_const_0 ) and (spinc_convention != _sage_const_1 ):
                raise Exception("Third parameter must be 0 or 1.")
            s_rep = Matrix(s_rep).T
            if spinc_convention == _sage_const_0 :
                for i in range(_sage_const_0 , self.vertex_count):
                    if (float(s_rep[i,_sage_const_0 ])-float(self.weight_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                        raise Exception("Your selected spin^c convention is to\
                                        use characteristic vectors, but second\
                                        parameter is not characteristic.")
                k = s_rep
                a = s_rep - self.weight_vector - self.degree_vector
            if spinc_convention == _sage_const_1 :
                for i in range(_sage_const_0 , self.vertex_count):
                    if (float(s_rep[i,_sage_const_0 ])-float(self.degree_vector[i, _sage_const_0 ])) % _sage_const_2  != _sage_const_0 :
                        raise Exception("Your selected spin^c convention is to\
                                        use vectors congruent mod 2 to the\
                                        degree vector, but second parameter\
                                        does not satisfy this.")
                k = s_rep + self.weight_vector + self.degree_vector
                a = s_rep

            k_squared = self.char_vector_properties(k.T)[_sage_const_2 ]

            normalization_term = -(k_squared + _sage_const_3 *self.vertex_count
                                   + sum(self.weight_vector)[_sage_const_0 ])/_sage_const_4                                    + sum(k)[_sage_const_0 ]/_sage_const_2                                    - sum(self.weight_vector + self.degree_vector)[_sage_const_0 ]/_sage_const_4
            M = self.intersection_form
            M_inv = M.inverse()

            min_vector = -(_sage_const_1 /_sage_const_2 )*M_inv*a
            min_level = ((a.T*M_inv*a)[_sage_const_0 ,_sage_const_0 ])/_sage_const_4

            bounding_box = []
            for i in range(_sage_const_0 , self.vertex_count):
                if min_level % _sage_const_1  == _sage_const_0 :
                    x = _sage_const_2 *math.sqrt(-(self.weight_vector[i, _sage_const_0 ])*(n-_sage_const_1 ))
                else:
                    x = _sage_const_2 *math.sqrt(-(self.weight_vector[i, _sage_const_0 ])*n)
                bounding_box.append([-x, x])

            F_supp = []
            for i in range(_sage_const_0 , self.vertex_count):
                if self.degree_vector[i, _sage_const_0 ] == _sage_const_0 :
                    if bounding_box[i][_sage_const_0 ]<= -_sage_const_2  and bounding_box[i][_sage_const_1 ]>= _sage_const_2 :
                        F_supp.append([-_sage_const_2 , _sage_const_0 , _sage_const_2 ])
                    elif bounding_box[i][_sage_const_0 ]<= -_sage_const_2  and bounding_box[i][_sage_const_1 ]< _sage_const_2 :
                        F_supp.append([-_sage_const_2 , _sage_const_0 ])
                    elif bounding_box[i][_sage_const_0 ]> -_sage_const_2  and bounding_box[i][_sage_const_1 ]>= _sage_const_2 :
                        F_supp.append([_sage_const_0 , _sage_const_2 ])
                    else:
                        F_supp.append([_sage_const_0 ])
                elif self.degree_vector[i, _sage_const_0 ] == _sage_const_1 :
                    if bounding_box[i][_sage_const_0 ]<= -_sage_const_1  and bounding_box[i][_sage_const_1 ]>= _sage_const_1 :
                        F_supp.append([-_sage_const_1 , _sage_const_1 ])
                    elif bounding_box[i][_sage_const_0 ]<= -_sage_const_1  and bounding_box[i][_sage_const_1 ]<_sage_const_1 :
                        F_supp.append([-_sage_const_1 ])
                    elif bounding_box[i][_sage_const_0 ]> -_sage_const_1  and bounding_box[i][_sage_const_1 ]>=_sage_const_1 :
                        F_supp.append([_sage_const_1 ])
                    else:
                        return _sage_const_0
                elif self.degree_vector[i, _sage_const_0 ] == _sage_const_2 :
                    F_supp.append([_sage_const_0 ])
                else:
                    r = self.degree_vector[i, _sage_const_0 ]-_sage_const_2
                    values = []
                    if bounding_box[i][_sage_const_0 ] <=-r:
                        values.append(-r)
                        for j in range(_sage_const_1 , floor((-r-bounding_box[i][_sage_const_0 ])/_sage_const_2 )+_sage_const_1 ):
                            values.append(-r - _sage_const_2 *j)
                    if bounding_box[i][_sage_const_1 ] >=r:
                        values.append(r)
                        for j in range(_sage_const_1 , floor((bounding_box[i][_sage_const_1 ]-r)/_sage_const_2 )+_sage_const_1 ):
                            values.append(r + _sage_const_2 *j)
                    if len(values)==_sage_const_0 :
                        return _sage_const_0
                    F_supp.append(copy(values))
            iterator = product(*F_supp)

            def F_hat_pre_comp(y):
                F = _sage_const_1
                for i in range(_sage_const_0 , self.vertex_count):
                    if self.degree_vector[i, _sage_const_0 ] == _sage_const_0 :
                        if y[i, _sage_const_0 ] == _sage_const_0 :
                            F = -_sage_const_2 *F
                        elif y[i, _sage_const_0 ] != _sage_const_2  and y[i, _sage_const_0 ]!= -_sage_const_2 :
                            F = _sage_const_0
                            return F
                    elif self.degree_vector[i, _sage_const_0 ] == _sage_const_1 :
                        if y[i, _sage_const_0 ] == _sage_const_1 :
                            F = -F
                        elif y[i, _sage_const_0 ] != -_sage_const_1 :
                            F = _sage_const_0
                            return F
                    elif self.degree_vector[i, _sage_const_0 ] == _sage_const_2 :
                        if y[i, _sage_const_0 ] != _sage_const_0 :
                            F = _sage_const_0
                            return F
                    else:
                        if abs(y[i, _sage_const_0 ]) >= self.degree_vector[i, _sage_const_0 ]-_sage_const_2 :
                            F = F*(_sage_const_1 /_sage_const_2 )*sign(y[i,_sage_const_0 ])**(self.degree_vector[i, _sage_const_0 ])
                            F = F*binomial((self.degree_vector[i, _sage_const_0 ]
                                            + abs(y[i, _sage_const_0 ]))/_sage_const_2 -_sage_const_2 ,
                                            self.degree_vector[i, _sage_const_0 ] -_sage_const_3 )
                        else:
                            F = _sage_const_0
                            return F
                return F

            exponents = [ceil(min_level) + i for i in range(_sage_const_0 , n)]
            coefficients = n*[_sage_const_0 ]

            for y in iterator:
                y = Matrix(y).T
                c = -((y.T*M_inv*y)[_sage_const_0 ,_sage_const_0 ])/_sage_const_4
                if frac(min_level) == _sage_const_0 :
                    if c <= n-_sage_const_1 :
                        x = (_sage_const_1 /_sage_const_2 )*M_inv*(y-a)
                        if x in MatrixSpace(ZZ, self.vertex_count, _sage_const_1 ):
                            ind = c
                            coefficients[ind] = coefficients[ind] + F_hat_pre_comp(y)

                else:
                    if c <= n:
                        x = (_sage_const_1 /_sage_const_2 )*M_inv*(y-a)
                        if x in MatrixSpace(ZZ, self.vertex_count, _sage_const_1 ):
                            ind = floor(c)
                            coefficients[ind] = coefficients[ind] + F_hat_pre_comp(y)

            zhat_list = [(coefficients[i], exponents[i] + normalization_term) for i in range(_sage_const_0 , n)]

            R = PuiseuxSeriesRing(QQ, names=('q',)); (q,) = R._first_ngens(1)

            truncated_zhat = _sage_const_0
            for x in zhat_list:
                truncated_zhat = truncated_zhat + x[_sage_const_0 ]*q**(x[_sage_const_1 ])
            return truncated_zhat

        except Exception as e:
            print(e)
